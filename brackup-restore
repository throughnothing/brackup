#!/usr/bin/perl

# TODO: skip-if-exists (and ignore zero byte files)
# TODO: continue-on-errors
# Error doing restore: File restore/.brackup-digest.db (.brackup-digest.db) already exists.  Aborting. at /raid/bradfitz/proj/brackup/trunk/lib/Brackup/Restore.pm line 157, <$fh> line 20.

=head1 NAME

brackup-restore - The brackup restore tool.

=head1 SYNOPSIS

 $ brackup-restore --from=foo.brackup --to=<base_directory>
 $ brackup-restore --from=foo.brackup --to=<base_directory> --all
 $ brackup-restore --from=foo.brackup --to=<base_directory> --just=<file>
 $ brackup-restore --from=foo.brackup --to=<base_directory> --just=<dir>

=head2 OPTIONS

=over 4

=item --from=NAME

Required.  The backup metafile, describing the tree you want to
restore.  Probably named like "source-YYYYMMDD.brackup".  If you lost
it, it's also stored on your backup target, and you can fetch it with
L<brackup-target>.

=item --to=NAME

Required.  The destination root directory for your restored files.

=item --all

Restore all files. This is the default if not specified.

=item --just="DIRECTORY"

Restore just the directory named.  (and all contents thereunder)

=item --just="FILE"

Restore just the file named.

=back

=head1 WARRANTY

Brackup is distributed as-is and comes without warranty of any kind,
expressed or implied.  We aren't responsible for your data loss.

=head1 AUTHOR

Brad Fitzpatrick E<lt>brad@danga.comE<gt>

Copyright (c) 2006-2007 Six Apart, Ltd. All rights reserved.

This module is free software. You may use, modify, and/or redistribute this
software under the terms of same terms as perl itself.

=cut

use strict;
use warnings;
use Getopt::Long;

use FindBin qw($Bin);
use lib "$Bin/lib";

use Brackup;
use Brackup::Util qw(tempfile);

my ($opt_verbose, $meta_file, $opt_help, $prefix);

# Make to default to the current directory
my $restore_dir = './';
# Default the --all option
my $opt_all = 1;

my $target_name;
my $newest_backup;

my $config_file = Brackup::Config->default_config_file_name;


usage() unless
    GetOptions(
               'from=s'    => \$meta_file,
               'to=s'      => \$restore_dir,
               'verbose'   => \$opt_verbose,
               'help'      => \$opt_help,
               'all'       => \$opt_all,
               'just=s'    => \$prefix,
               'config=s'  => \$config_file,
               'target=s'  => \$target_name,
               );

if ($opt_help) {
    eval "use Pod::Usage;";
    Pod::Usage::pod2usage( -verbose => 1, -exitval => 0 );
    exit 0;
}

my $config = eval { Brackup::Config->load($config_file) } or
    usage($@);

usage() unless $meta_file && $restore_dir && ($prefix || $opt_all);
usage("Given directory isn't a directory") unless -d $restore_dir;
$prefix ||= "";  # with -all, "", which means everything

# HACK: if $meta_file is not a file, check if its an online backup
if (! -e $meta_file){
	# If target is not defined, die
	# we dont know which target to look for backups on
	die "Given restore file isn't a file" unless ($target_name);

	# Check if its on the Target
	my $target = $config->load_target($target_name)
		or die "Could not find target '$target_name' in your brackup.conf!"; 
	my @backup_matches = 
		grep ($_->filename =~ /^($meta_file$)|($meta_file-\d+$)/,$target->backups);

	# Make sure we fonud something
	die "Could not find a matching backup on the target!" unless @backup_matches;

	$newest_backup = $backup_matches[0]->filename;
	$meta_file = "$newest_backup.brackup";

	$target->get_backup($newest_backup);
}

my $restore = Brackup::Restore->new(
                                    to     => $restore_dir,
                                    prefix => $prefix,
                                    file   => $meta_file,
                                    verbose => $opt_verbose,
                                    );

my $restore_result = eval { $restore->restore };

if ($newest_backup && -e $meta_file){
	# Remove the newest_backup file if we had to download it
	`rm -f $meta_file`;
}

if ($restore_result){
    warn "Restore complete.\n" if $opt_verbose;
    exit 0;
} else {
    chomp $@;
    warn "Error doing restore: $@\n";
    exit 1;
}

sub usage {
    my $why = shift || "";
    if ($why) {
        $why =~ s/\s+$//;
        $why = "Error: $why\n\n";
    }
    die "${why}brackup-restore --from=[metafile.brackup] --to=[restore_dir] <--all|--just=[what]>\nbrackup-restore --help\n";
}
